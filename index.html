<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title> RaspberryIO - Pi's hardware access from .NET | RaspberryIO - Pi's hardware access from Mono </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content=" RaspberryIO - Pi's hardware access from .NET | RaspberryIO - Pi's hardware access from Mono ">
    <meta name="generator" content="docfx 2.39.2.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/bootstrap.min.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="logo" src="best-practices/resources/images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><a href="https://www.nuget.org/packages/Unosquare.Raspberry.IO"><img src="https://img.shields.io/nuget/dt/Unosquare.Raspberry.IO.svg" alt="NuGet"></a>
<a href="https://github.com/igrigorik/ga-beacon"><img src="https://ga-beacon.appspot.com/UA-8535255-2/unosquare/raspberryio/" alt="Analytics"></a>
<a href="https://ci.appveyor.com/project/geoperez/raspberryio/branch/master"><img src="https://ci.appveyor.com/api/projects/status/ufr4k5y96phtafqj/branch/master?svg=true" alt="Build status"></a>
<a href="https://travis-ci.org/unosquare/raspberryio"><img src="https://travis-ci.org/unosquare/raspberryio.svg?branch=master" alt="Build Status"></a></p>
<h1 id="img-srchttpsgithubcomunosquareraspberryiorawmasterlogosraspberryio-logo-32pngimg-raspberryio---pis-hardware-access-from-net"><img src="https://github.com/unosquare/raspberryio/raw/master/logos/raspberryio-logo-32.png"> RaspberryIO - <em>Pi&#39;s hardware access from .NET</em></h1>
<p><span class="emoji" shortcode="star">⭐</span> <em>Please star this project if you find it useful!</em></p>
<p>The Raspberry Pi&#39;s IO Functionality in an easy-to-use API for .NET (Mono/.NET Core). Our mission is to make .NET a first-class citizen in the Python-centric community of Raspberry Pi developers.</p>
<h1 id="-table-of-contents"> Table of contents</h1>
<ul>
<li><a href="#features">Features</a><ul>
<li><a href="#peripherals">Peripherals</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#running-the-latest-version-of-mono">Running the latest version of Mono</a><ul>
<li><a href="#for-debian-wheezy">For Debian Wheezy</a></li>
<li><a href="#for-debian-stretch">For Debian Stretch</a></li>
<li><a href="#handy-notes">Handy Notes</a></li>
</ul>
</li>
<li><a href="#running-net-core-2">Running .NET Core 2</a><ul>
<li><a href="#run-the-app-on-the-raspberry">Run the app on the raspberry</a></li>
</ul>
</li>
<li><a href="#the-camera-module">The Camera Module</a><ul>
<li><a href="#capturing-images">Capturing Images</a></li>
<li><a href="#capturing-video">Capturing Video</a></li>
</ul>
</li>
<li><a href="#obtaining-board-and-system-information">Obtaining Board and System Information</a></li>
<li><a href="#using-the-gpio-pins">Using the GPIO Pins</a><ul>
<li><a href="#pin-information">Pin Information</a></li>
<li><a href="#digital-read-and-write">Digital Read and Write</a></li>
<li><a href="#analog-level-read-and-write">Analog (Level) Read and Write</a></li>
<li><a href="#hardware-pwm">Hardware PWM</a></li>
<li><a href="#software-pwm">Software PWM</a></li>
<li><a href="#tone-generation">Tone Generation</a></li>
<li><a href="#interrupts-and-callbacks">Interrupts and Callbacks</a></li>
</ul>
</li>
<li><a href="#using-the-spi-bus">Using the SPI Bus</a></li>
<li><a href="#i2c-to-connect-ics">I2C to connect ICs</a></li>
<li><a href="#timing-and-threading">Timing and Threading</a></li>
<li><a href="#serial-ports-uart">Serial Ports (UART)</a></li>
<li><a href="#similar-projects">Similar Projects</a></li>
</ul>
<h2 id="features">Features</h2>
<p>This library enables developers to use the various Raspberry Pi&#39;s hardware modules:</p>
<ul>
<li><code>Pi.Camera</code> Provides access to the official Raspberry Pi Camera module.</li>
<li><code>Pi.Info</code> Provides information on this Raspberry Pi&#39;s CPU and form factor.</li>
<li><code>Pi.Gpio</code> Provides access to the Raspberry Pi&#39;s GPIO as a collection of GPIO Pins.</li>
<li><code>Pi.Spi</code> Provides access to the 2-channel SPI bus.</li>
<li><code>Pi.I2c</code> Provides access to the functionality of the i2c bus.</li>
<li><code>Pi.Timing</code> Provides access to The PI&#39;s Timing and threading API.</li>
</ul>
<p>To run the program <code>mono myprogram.exe</code> in order to work correctly. You no longer require running as root.</p>
<p>This library depends on the wonderful <code>WiringPi</code> library available <a href="http://wiringpi.com/">here</a>. You do not need to install this library yourself. The <code>RaspberryIO</code> assembly will automatically extract the compiled binary of the library in the same path as the entry assembly.</p>
<h3 id="peripherals">Peripherals</h3>
<p>We offer an additional package with helpful classes to use peripherals, many of them are from pull requests from our contributors. The current set of peripherals supported are:</p>
<ul>
<li>Infrared Sensor HX-1838</li>
<li>Led Strip APA-102C</li>
<li>NFC/RFID Controller MFRC-522</li>
<li>Temperature Sensor AM-2302</li>
<li>Generic Button</li>
</ul>
<h2 id="installation">Installation</h2>
<p>Install basic Raspberry.IO package:
<a href="https://badge.fury.io/nu/Unosquare.Raspberry.IO"><img src="https://badge.fury.io/nu/Unosquare.Raspberry.IO.svg" alt="NuGet version"></a></p>
<pre><code>PM&gt; Install-Package Unosquare.Raspberry.IO
</code></pre><p>Install Raspberry.IO Peripherals package:
<a href="https://badge.fury.io/nu/Unosquare.RaspberryIO.Peripherals"><img src="https://badge.fury.io/nu/Unosquare.RaspberryIO.Peripherals.svg" alt="NuGet version"></a></p>
<pre><code>PM&gt; Install-Package Unosquare.RaspberryIO.Peripherals
</code></pre><h2 id="running-the-latest-version-of-mono">Running the latest version of Mono</h2>
<p>It is recommended that you install the latest available release of Mono because what is available in the Raspbian repo is quite old (3.X). These commands were tested using Raspbian Jessie. The version of Mono that is installed at the time of this writing is:</p>
<pre><code>Mono JIT compiler version 5.4.1.6 (tarball Wed Nov  8 21:42:16 UTC 2017)
</code></pre><p>The commands to get Mono installed are the following:</p>
<h3 id="for-debian-wheezy">For Debian Wheezy</h3>
<pre><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install mono-complete
sudo apt-get install dirmngr
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
echo &quot;deb http://download.mono-project.com/repo/debian wheezy main&quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list
sudo apt-get update
sudo apt-get dist-upgrade
</code></pre><h3 id="for-debian-stretch">For Debian Stretch</h3>
<pre><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install mono-complete
sudo apt-get install dirmngr
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
echo &quot;deb http://download.mono-project.com/repo/debian stretch main&quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list
sudo apt-get update
sudo apt-get dist-upgrade
</code></pre><p>Now, verify your version of Mono by running <code>mono --version</code>. Version 4.6 and above should be good enough.</p>
<h3 id="handy-notes">Handy Notes</h3>
<p>In order to setup Wi-Fi, run: <code>sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</code></p>
<p>A good file should look like this:</p>
<pre><code>country=US
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&quot;your_real_wifi_ssid&quot;
    scan_ssid=1
    psk=&quot;your_real_password&quot;
}
</code></pre><p>And then restart the services as follows:</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl restart dhcpcd
</code></pre><p>You can also configure most boot options by running: <code>sudo raspi-config</code></p>
<h2 id="running-net-core-21">Running .NET Core 2.1</h2>
<p>This project can also run in .NET Core 2.1. To install please execute the following commands:</p>
<pre><code>$ sudo apt-get -y update
$ sudo apt-get -y install libunwind8 gettext
$ wget https://dotnetcli.blob.core.windows.net/dotnet/Sdk/2.1.300-rc1-008673/dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz
$ wget https://dotnetcli.blob.core.windows.net/dotnet/aspnetcore/Runtime/2.1.0-rc1-final/aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz
$ sudo mkdir /opt/dotnet
$ sudo tar -xvf dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz -C /opt/dotnet/
$ sudo tar -xvf aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz -C /opt/dotnet/
$ sudo ln -s /opt/dotnet/dotnet /usr/local/bin
$ dotnet --info
</code></pre><h3 id="run-the-app-on-the-raspberry">Run the app on the raspberry</h3>
<ul>
<li><p>You need to publish the project and you can accomplish this by using <a href="https://github.com/unosquare/sshdeploy">dotnet-sshdeploy</a> but first, you must edit these properties inside the Playground&#39;s csproj file in order to establish an ssh connection with your raspberry</p>
<pre><code class="lang-xml">&lt;SshDeployHost&gt;172.16.17.54&lt;/SshDeployHost&gt;
&lt;SshDeployTargetPath&gt;/home/pi/Playground&lt;/SshDeployTargetPath&gt;
&lt;SshDeployUsername&gt;pi&lt;/SshDeployUsername&gt;
&lt;SshDeployPassword&gt;raspberry&lt;/SshDeployPassword&gt;
</code></pre></li>
<li><p>Install dotnet-sshdeploy as a global tool by running </p>
<pre><code>$ dotnet tool install -g dotnet-sshdeploy
</code></pre></li>
<li><p>Execute <code>dotnet-sshdeploy push</code> in the same folder where Unosquare.RaspberryIO.Playground.csproj resides and if everything executes correctly you should see an output like this:</p>
<pre><code>SSH Deployment Tool [Version 0.3.1.0]
(c)2015 - 2017 Unosquare SA de CV. All Rights Reserved.
For additional help, please visit https://github.com/unosquare/sshdeploy
Deploying...
  Configuration   Debug
  Framework       net452
  Source Path     C:\raspberryio\src\Unosquare.RaspberryIO.Playground\bin\Debug\net452\publish
  Excluded Files  .ready|.vshost.exe|.vshost.exe.config
  Target Address  192.16.17.54:22
  Username        pi
  Target Path     /home/pi/Playground
  Clean Target    NO
  Pre Deployment  
  Post Deployment 
Connecting to host 192.16.17.54:22 via SSH.
Connecting to host 192.16.17.54:22 via SFTP.

  Target Path &#39;/home/pi/Playground&#39; does not exist. -- Will attempt to create.
  Target Path &#39;/home/pi/Playground&#39; created successfully.
  Cleaning Target Path &#39;/home/pi/Playground&#39;

  Deploying 8 files.
  Finished deployment in 1.25 seconds.
Completed.
</code></pre></li>
<li><strong>The default TargetFramework is</strong> <code>net452</code> <strong>but you can change this by either modifying the RuntimeIdentifier property inside the csproj file or supplying it as a parameter like this</strong><code>dotnet-sshdeploy push -f netcoreapp2.0</code>. <strong>More information about dotnet-sshdeploy see <a href="https://github.com/unosquare/sshdeploy">this</a></strong></li>
<li>Give permissions to run the project</li>
</ul>
<pre><code>ubuntu@ubuntu:~/publish$ sudo chmod u+x *
</code></pre><ul>
<li>Run the project</li>
</ul>
<pre><code>ubuntu@ubuntu:~/publish$ ./Unosquare.RaspberryIO.Playground
</code></pre><h2 id="the-camera-module">The Camera Module</h2>
<p>The <code>Pi.Camera</code> module uses <code>raspivid</code> and <code>raspistill</code> to access the camera so they must be installed in order for your program to work properly. <code>raspistill</code> arguments are specified in an instance of the <code>CameraStillSettings</code> class, while the <code>raspivid</code> arguments are specified in an instance of the <code>CameraVideoSettings</code> class. </p>
<h3 id="capturing-images">Capturing Images</h3>
<p>The <code>Pi.Camera.CaptureImage*</code> methods simply return an array of bytes containing the captured image. There are synchronous and asynchronous falvors of these methods so you can use the familiar <code>async</code> and <code>await</code> pattern to capture your images. All <code>raspistill</code> arguments (except for those that control user interaction such as <code>-k</code>) are available via the <code>CameraStillSettings</code>. To start, create a new instance of the <code>CameraStillSettings</code> class and pass it on to your choice of the <code>Pi.Camera.CaptureImage*</code> methods. There are shortcut methods available that simply take a JPEG image at the given Width and Height. By default, the shortcut methods set the JPEG quality at 90%.</p>
<p>Example using a shortcut method:</p>
<pre><code class="lang-csharp">static void TestCaptureImage()
{
    var pictureBytes = Pi.Camera.CaptureImageJpeg(640, 480);
    var targetPath = &quot;/home/pi/picture.jpg&quot;;
    if (File.Exists(targetPath))
        File.Delete(targetPath);

    File.WriteAllBytes(targetPath, pictureBytes);
    Console.WriteLine($&quot;Took picture -- Byte count: {pictureBytes.Length}&quot;);
}
</code></pre><p>Example using a CaptureImage method:</p>
<pre><code class="lang-csharp">// TODO: example code here
</code></pre><h3 id="capturing-video">Capturing Video</h3>
<p>Capturing video streams is somewhat different but it is still very easy to do. The concept behind it is to <em>Open</em> a video stream providing your own callback. When opening the stream <code>Raspberry IO</code> will spawn a separate thread and will not block the execution of your code, but it will continually call your callback method containing the bytes that are being read from the camera until the <em>Close</em> method is called or until the timeout is reached.</p>
<p>Example of capturing a stream of H.264 video</p>
<pre><code class="lang-csharp">static void TestCaptureVideo()
{
    // Setup our working variables
    var videoByteCount = 0;
    var videoEventCount = 0;
    var startTime = DateTime.UtcNow;

    // Configure video settings
    var videoSettings = new CameraVideoSettings()
    {
        CaptureTimeoutMilliseconds = 0,
        CaptureDisplayPreview = false,
        ImageFlipVertically = true,
        CaptureExposure = CameraExposureMode.Night,
        CaptureWidth = 1920,
        CaptureHeight = 1080
    };

    try
    {
        // Start the video recording
        Pi.Camera.OpenVideoStream(videoSettings,
            onDataCallback: (data) =&gt; { videoByteCount += data.Length; videoEventCount++; },
            onExitCallback: null);

        // Wait for user interaction
        startTime = DateTime.UtcNow;
        Console.WriteLine(&quot;Press any key to stop reading the video stream . . .&quot;);
        Console.ReadKey(true);
    }
    catch (Exception ex)
    {
        Console.WriteLine($&quot;{ex.GetType()}: {ex.Message}&quot;);
    }
    finally
    {
        // Always close the video stream to ensure raspivid quits
        Pi.Camera.CloseVideoStream();

        // Output the stats
        var megaBytesReceived = (videoByteCount / (1024f * 1024f)).ToString(&quot;0.000&quot;);
        var recordedSeconds = DateTime.UtcNow.Subtract(startTime).TotalSeconds.ToString(&quot;0.000&quot;);
        Console.WriteLine($&quot;Capture Stopped. Received {megaBytesReceived} Mbytes in {videoEventCount} callbacks in {recordedSeconds} seconds&quot;);
    }            
}
</code></pre><h2 id="obtaining-board-and-system-information">Obtaining Board and System Information</h2>
<p><code>RaspberryIO</code> contains useful utilities to obtain information about the board it is running on. You can simply call the <code>Pi.Info.ToString()</code> method to obtain a dump of all system properties as a single <code>string</code>, or you can use the individual properties such as Installed RAM, Processor Count, Raspberry Pi Version, Serial Number, etc. There&#39;s not a lot more to this.
Please note <code>Pi.Info</code> depends on <code>Wiring Pi</code>, and the <code>/proc/cpuinfo</code> and <code>/proc/meminfo</code> files.</p>
<h2 id="using-the-gpio-pins">Using the GPIO Pins</h2>
<p>Pin reference for the B plus (B+) - Header P1</p>
<table>
<thead>
<tr>
<th>BCM</th>
<th>wPi</th>
<th>Name</th>
<th>Mode</th>
<th>V</th>
<th>L</th>
<th>R</th>
<th>V</th>
<th>Mode</th>
<th>Name</th>
<th>wPi</th>
<th>BCM</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>3.3v</td>
<td></td>
<td></td>
<td><strong>01</strong></td>
<td><strong>02</strong></td>
<td></td>
<td></td>
<td>5v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>8</td>
<td>SDA.1</td>
<td>ALT0</td>
<td>1</td>
<td><strong>03</strong></td>
<td><strong>04</strong></td>
<td></td>
<td></td>
<td>5V</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>9</td>
<td>SCL.1</td>
<td>ALT0</td>
<td>1</td>
<td><strong>05</strong></td>
<td><strong>06</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>7</td>
<td>GPIO. 7</td>
<td>IN</td>
<td>1</td>
<td><strong>07</strong></td>
<td><strong>08</strong></td>
<td>1</td>
<td>ALT0</td>
<td>TxD</td>
<td>15</td>
<td>14</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>09</strong></td>
<td><strong>10</strong></td>
<td>1</td>
<td>ALT0</td>
<td>RxD</td>
<td>16</td>
<td>15</td>
</tr>
<tr>
<td>17</td>
<td>0</td>
<td>GPIO. 0</td>
<td>IN</td>
<td>0</td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 1</td>
<td>1</td>
<td>18</td>
</tr>
<tr>
<td>27</td>
<td>2</td>
<td>GPIO. 2</td>
<td>IN</td>
<td>0</td>
<td><strong>13</strong></td>
<td><strong>14</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>3</td>
<td>GPIO. 3</td>
<td>IN</td>
<td>0</td>
<td><strong>15</strong></td>
<td><strong>16</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 4</td>
<td>4</td>
<td>23</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.3v</td>
<td></td>
<td></td>
<td><strong>17</strong></td>
<td><strong>18</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 5</td>
<td>5</td>
<td>24</td>
</tr>
<tr>
<td>10</td>
<td>12</td>
<td>MOSI</td>
<td>IN</td>
<td>0</td>
<td><strong>19</strong></td>
<td><strong>20</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>13</td>
<td>MISO</td>
<td>IN</td>
<td>0</td>
<td><strong>21</strong></td>
<td><strong>22</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 6</td>
<td>6</td>
<td>25</td>
</tr>
<tr>
<td>11</td>
<td>14</td>
<td>SCLK</td>
<td>IN</td>
<td>0</td>
<td><strong>23</strong></td>
<td><strong>24</strong></td>
<td>1</td>
<td>IN</td>
<td>CE0</td>
<td>10</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>25</strong></td>
<td><strong>26</strong></td>
<td>1</td>
<td>IN</td>
<td>CE1</td>
<td>11</td>
<td>7</td>
</tr>
<tr>
<td>0</td>
<td>30</td>
<td>SDA.0</td>
<td>IN</td>
<td>1</td>
<td><strong>27</strong></td>
<td><strong>28</strong></td>
<td>1</td>
<td>IN</td>
<td>SCL.0</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>21</td>
<td>GPIO.21</td>
<td>IN</td>
<td>1</td>
<td><strong>29</strong></td>
<td><strong>30</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>22</td>
<td>GPIO.22</td>
<td>IN</td>
<td>1</td>
<td><strong>31</strong></td>
<td><strong>32</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.26</td>
<td>26</td>
<td>12</td>
</tr>
<tr>
<td>13</td>
<td>23</td>
<td>GPIO.23</td>
<td>IN</td>
<td>0</td>
<td><strong>33</strong></td>
<td><strong>34</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>24</td>
<td>GPIO.24</td>
<td>IN</td>
<td>0</td>
<td><strong>35</strong></td>
<td><strong>36</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.27</td>
<td>27</td>
<td>16</td>
</tr>
<tr>
<td>26</td>
<td>25</td>
<td>GPIO.25</td>
<td>IN</td>
<td>0</td>
<td><strong>37</strong></td>
<td><strong>38</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.28</td>
<td>28</td>
<td>20</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>39</strong></td>
<td><strong>40</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.29</td>
<td>29</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>But wait for a second, Where are Wiring Pi (wPi) pins 17 through 20? The above diagram shows the pins of GPIO Header P1. There is an additional GPIO header on the Pi called P5. <a href="http://www.raspberrypi-spy.co.uk/2012/09/raspberry-pi-p5-header/">More info available here</a></p>
<p>In order to access the pins, use <code>Pi.Gpio</code>. The pins can have multiple behaviors and fortunately <code>Pi.Gpio</code> can be iterated, addressed by index, addressed by Wiring Pi pin number and provides the pins as publicly accessible properties.</p>
<p>Here is an example of addressing the pins in all the various ways:</p>
<pre><code class="lang-csharp">public static void TestLedBlinking()
{
    // Get a reference to the pin you need to use.
    // All 3 methods below are exactly equivalent
    var blinkingPin = Pi.Gpio[0];
    blinkingPin = Pi.Gpio[WiringPiPin.Pin00];
    blinkingPin = Pi.Gpio.Pin00;

    // Configure the pin as an output
    blinkingPin.PinMode = GpioPinDriveMode.Output;

    // perform writes to the pin by toggling the isOn variable
    var isOn = false;
    for (var i = 0; i &lt; 20; i++)
    {
        isOn = !isOn;
        blinkingPin.Write(isOn);
        System.Threading.Thread.Sleep(500);
    }
}
</code></pre><h3 id="pin-information">Pin Information</h3>
<p>All pins have handy properties and methods that you can use to drive them. For example, you can examine the <code>Capabilities</code> property to find out which features are available on the pin. You can also use the <code>PinMode</code> property to get or set the operating mode of the pin. Please note that the value of the <code>PinMode</code> property is by default set to <em>Input</em> and it will return the last mode you set the property to.</p>
<h3 id="digital-read-and-write">Digital Read and Write</h3>
<p>It is very easy to read and write values to the pins. In general, it is a 2-step process.</p>
<ul>
<li>Set the pin mode</li>
<li>Read or write the bit value</li>
</ul>
<p>Reading the value of a pin example:</p>
<pre><code class="lang-csharp">Pi.Gpio.Pin02.PinMode = GpioPinDriveMode.Input;
// The below lines are reoughly equivalent
var isOn = Pi.Gpio.Pin02.Read(); // Reads as a boolean
var pinValue = Pi.Gpio.Pin02.ReadValue(); // Reads as a GpioPinValue
</code></pre><p>Writing to a pin example</p>
<pre><code class="lang-csharp">Pi.Gpio.Pin02.PinMode = GpioPinDriveMode.Output;
// The below lines are reoughly equivalent
Pi.Gpio.Pin02.Write(true); // Writes a boolean
Pi.Gpio.Pin02.Write(GpioPinValue.High); // Writes a pin value
</code></pre><h3 id="analog-level-read-and-write">Analog (Level) Read and Write</h3>
<p>TODO</p>
<h3 id="hardware-pwm">Hardware PWM</h3>
<p>Simple code for led dimming:</p>
<pre><code class="lang-csharp">   var pin = Pi.Gpio[P1.Gpio18];
   pin.PinMode = GpioPinDriveMode.PwmOutput;
   pin.PwmMode = PwmMode.Balanced;
   pin.PwmClockDivisor = 2; 
   while (true)
   {
      for (int x = 0; x &lt;= 100; x++)
      {
         pin.PwmRegister = (int)pin.PwmRange / 100 * x;
         Thread.Sleep(10);
      }

      for (int x = 0; x &lt;= 100; x++)
      {
         pin.PwmRegister = (int)pin.PwmRange - ((int)pin.PwmRange / 100 * x);
         Thread.Sleep(10);
      }
   }
</code></pre><p><strong>PwmRange</strong> is the maximun value of the pulse width, than means 100% of pulse width. Changing this value allows you to have a more fine or coarse control of the pulse width (default 1024).</p>
<p><strong>PwmRegister</strong> is the current pulse width. Changing this value allows you to change the current pulse width and thus the duty cycle.</p>
<p><strong>Duty Cycle</strong> is equals to <strong>PwmRegister</strong> divide by <strong>PwmRange</strong>. Assuming a <strong>PwmRange</strong> value of 1024 (default), we have:</p>
<table>
<thead>
<tr>
<th style="text-align:center">PwmRegister</th>
<th style="text-align:center">Duty Cycle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0%</td>
</tr>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center">25%</td>
</tr>
<tr>
<td style="text-align:center">512</td>
<td style="text-align:center">50%</td>
</tr>
<tr>
<td style="text-align:center">768</td>
<td style="text-align:center">75%</td>
</tr>
<tr>
<td style="text-align:center">1024</td>
<td style="text-align:center">100%</td>
</tr>
</tbody>
</table>
<h3 id="software-pwm">Software PWM</h3>
<p>TODO</p>
<h3 id="tone-generation">Tone Generation</h3>
<p>You can emit tones by using SoftToneFrequency. Example:</p>
<pre><code class="lang-csharp">// Get a reference to the pin
var passiveBuzzer = Pi.Gpio[WiringPiPin.Pin01];
// Set the frequency to Alto Do (523Hz)
passiveBuzzer.SoftToneFrequency = 523
// Wait 1 second
System.Threading.Thread.Sleep(1000);
// And stop
passiveBuzzer.SoftToneFrequency = 0;
</code></pre><h3 id="interrupts-and-callbacks">Interrupts and Callbacks</h3>
<p>Register an Interrupt Callback example:</p>
<pre><code class="lang-csharp">using System;
using Unosquare.RaspberryIO;
using Unosquare.RaspberryIO.Gpio;

class Program
{
  // Define the implementation of the delegate;
  static void ISRCallback()
  {
     Console.WriteLine(&quot;Pin Activated...&quot;);         
  }

  static void Main(string[] args)
  {
        Console.WriteLine(&quot;Gpio Interrupts&quot;);
        var pin = Pi.Gpio.Pin00;
        pin.PinMode = GpioPinDriveMode.Input;
        pin.RegisterInterruptCallback(EdgeDetection.FallingEdge, ISRCallback);
        Console.ReadKey();
  }
}
</code></pre><h2 id="using-the-spi-bus">Using the SPI Bus</h2>
<p>I really liked the following description from <a href="http://nrqm.ca/nrf24l01/serial-peripheral-interface/">Neil&#39;s Log Book</a>: <em>The SPI (Serial Peripheral Interface) protocol behaves like a ring buffer so that whenever the master sends a byte to the slave, the slave sends a byte back to the master. The slave can use this behavior to return a status byte, a response to a previous byte, or null data (the master may choose to read the returned byte or ignore it). The bus operates on a 4-wire interface.</em></p>
<p><code>RaspberryIO</code> provides easy access to the 2 SPI channels available on the Raspberry. The functionality depends on <code>Wiring Pi</code>&#39;s SPI library. Please note that you may need to issue the command <code>gpio load spi</code> before starting your application (or as a <code>System.Diagnostics.Process</code> when your application starts) if the SPI kernel drivers have not been loaded.</p>
<p>In order to use an SPI channel you <strong>MUST</strong> always set the <code>Channel0Frequency</code> or <code>Channel1Frequency</code> (depending on the channel you want to use) before calling the <code>SendReceive</code> method. If the property is not set beforehand the SPI channel will fail initialization. See an example below: </p>
<p>Example of using the SPI Bus</p>
<pre><code class="lang-csharp">Pi.Spi.Channel0Frequency = SpiChannel.MinFrequency;
var request = System.Text.Encoding.ASCII.GetBytes(&quot;HELLO!&quot;);
var response = Pi.Spi.Channel0.SendReceive(request);
</code></pre><h2 id="i2c-to-connect-ics">I2C to connect ICs</h2>
<p>The Inter IC Bus (I2C) is a cousin of the SPI bus but it is somewhat more complex and it does not work as a ring buffer like the SPI bus. It also connects all of its slave devices in series and depends on 2 lines only. There is a nice tutorial on setting up and using the I2C bus at <a href="http://www.robot-electronics.co.uk/i2c-tutorial">Robot Electronics</a>. From their site: <em>The physical bus is just two wires, called SCL and SDA. SCL is the clock line. It is used to synchronize all data transfers over the I2C bus. SDA is the data line. The SCL &amp; SDA lines are connected to all devices on the I2C bus. There needs to be a third wire which is just the ground or 0 volts. There may also be a 5volt wire is power is being distributed to the devices. Both SCL and SDA lines are &quot;open drain&quot; drivers. What this means is that the chip can drive its output low, but it cannot drive it high. For the line to be able to go high you must provide pull-up resistors to the 5v supply. There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line. You only need one set of pull-up resistors for the whole I2C bus, not for each device.</em></p>
<p><code>RaspberryIO</code> provides easy access to the I2C bus available on the Raspberry. The functionality depends on <code>Wiring Pi</code>&#39;s I2C library. Please note that you may need to issue the command <code>gpio load i2c</code> before starting your application (or as a <code>System.Diagnostics.Process</code> when your application starts) if the I2C kernel drivers have not been loaded. The default baud rate is 100Kbps. If you wish to initialize the bus at a different baud rate you may issue, for example, <code>gpio load i2c 200</code>. This will load the bus at 200kbps.</p>
<p>In order to detect I2C devices, you could use the <code>i2cdetect</code> system command. Just remember that on a Rev 1 Raspberry Pi it&#39;s device 0, and on a Rev. 2 it&#39;s device 1. e.g.</p>
<pre><code>i2cdetect -y 0 # Rev 1
i2cdetect -y 1 # Rev 2
</code></pre><p>Example of using the I2C Bus</p>
<pre><code class="lang-csharp">// Register a device on the bus
var myDevice = Pi.I2C.AddDevice(0x20);

// Simple Write and Read (there are algo register read and write methods)
myDevice.Write(0x44);
var response = myDevice.Read();

// List registered devices on the I2C Bus
foreach (var device in Pi.I2C.Devices)
{
    Console.WriteLine($&quot;Registered I2C Device: {device.DeviceId}&quot;);
}
</code></pre><h2 id="timing-and-threading">Timing and Threading</h2>
<p>TODO</p>
<h2 id="serial-ports-uart">Serial Ports (UART)</h2>
<p>Where is the serial port API? Well, it is something we will most likely add in the future. For now, you can simply use the built-in <code>SerialPort</code> class the .NET framework provides.</p>
<h2 id="similar-projects">Similar Projects</h2>
<ul>
<li><a href="https://github.com/raspberry-sharp/raspberry-sharp-io">Raspberry# IO</a></li>
<li><a href="https://github.com/danriches/WiringPi.Net">WiringPi.Net</a></li>
<li><a href="https://github.com/andycb/PiSharp">PiSharp</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="doc" align="center">
              <span class="small mobile-hide">
                <img id="logo" class="doc-logo" src="logos/raspberryio-logo-256.png" alt="">
              </span>
            </div>
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li class="top-sep">
                    <a href="https://github.com/unosquare/raspberryio/blob/master/README.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2017-2018 <a href="https://www.unosquare.com">Unosquare</a></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
