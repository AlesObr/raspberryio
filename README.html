<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title> RaspberryIO - Pi's hardware access from Mono | Unosquare LiteLib </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content=" RaspberryIO - Pi's hardware access from Mono | Unosquare LiteLib ">
    <meta name="generator" content="docfx 2.12.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="litelib-logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              
              <p><a href="https://badge.fury.io/nu/Unosquare.Raspberry.IO"><img src="https://badge.fury.io/nu/Unosquare.Raspberry.IO.svg" alt="NuGet version"></a>
<a href="https://github.com/igrigorik/ga-beacon"><img src="https://ga-beacon.appspot.com/UA-8535255-2/unosquare/raspberryio/" alt="Analytics"></a></p>
<h1 id="img-srchttpsgithubcomunosquareraspberryiorawmasterlogosraspberryio-logo-32pngimg-raspberryio---pis-hardware-access-from-mono"><img src="https://github.com/unosquare/raspberryio/raw/master/logos/raspberryio-logo-32.png"> RaspberryIO - <em>Pi&#39;s hardware access from Mono</em></h1>
<p>The Raspberry Pi&#39;s IO Functionality in an easy-to-use API for Mono/.NET/C#. Our mission is to make Mono a first-class citizen in the Python-centric community of Raspberry Pi developers.</p>
<p><em><span class="emoji" shortcode="star">⭐</span>Please star this project if you find it useful!</em></p>
<h2 id="features">Features</h2>
<p>This library enables developers to use the various Raspberry Pi&#39;s hardware modules</p>
<ul>
<li><code>Pi.Camera</code> Provides access to the offical Raspberry Pi Camera module.</li>
<li><code>Pi.Info</code> Provides information on this Raspberry Pi&#39;s CPU and form factor.</li>
<li><code>Pi.Gpio</code> Provides access to the Raspberry Pi&#39;s GPIO as a collection of GPIO Pins.</li>
<li><code>Pi.Spi</code> Provides access to the 2-channel SPI bus.</li>
<li><code>Pi.I2c</code> Provides access to the functionality of the i2c bus.</li>
<li><code>Pi.Timing</code> Provides access to The PI&#39;s Timing and threading API.</li>
</ul>
<p><em>Please note you program needs to be run with <code>sudo</code>. Example <code>sudo mono myprogram.exe</code> in order to work correctly.</em></p>
<p>This library depends on the wonderful <code>WiringPi</code> library avaialble <a href="http://wiringpi.com/">here</a>. You do not need to install this library yourself. The <code>RaspberryIO</code> assembly will automatically extract the compiled binary of the library in the same path as the entry assembly.</p>
<h2 id="nuget-installation">NuGet Installation:</h2>
<pre><code>PM&gt; Install-Package Unosquare.Raspberry.IO
</code></pre><h2 id="running-the-latest-version-of-mono">Running the latest version of Mono</h2>
<p>It is recommended that you install the latest available release of Mono because what is available in the Raspbian repo is quite old (3.X). These commands were tested using Raspbian Jessie. The version of Mono that is installed at the time of this writing is:</p>
<pre><code>Mono JIT compiler version 4.6.2 (Stable 4.6.2.7/08fd525 Mon Nov 14 12:43:54 UTC 2016)
</code></pre><p>The commands to get Mono installed are the following:</p>
<pre><code>sudo apt-get update
sudo apt-get upgrade
sudo apt-get install mono-complete
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
echo &quot;deb http://download.mono-project.com/repo/debian wheezy main&quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list
sudo apt-get update
sudo apt-get dist-upgrade
</code></pre><p>Now, verify your version of Mono by running <code>mono --version</code>. Version 4.6 and above should be good enough.</p>
<h2 id="the-camera-module">The Camera Module</h2>
<p>The <code>Pi.Camera</code> module uses <code>raspivid</code> and <code>raspistill</code> to access to camera so they must be installed in order for your program to work propely. <code>raspistill</code> arguments are specified in an instance of the <code>CameraStillSettings</code> class, while the <code>raspivid</code> arguments are specified in an instance of the <code>CameraVideoSettings</code> class. </p>
<h3 id="capturing-images">Capturing Images</h3>
<p>The <code>Pi.Camera.CaptureImage*</code> methods simply return an array of bytes containing the capture image. There are synchronous and asynchronous falvors of these methods so you can use the familiar <code>async</code> and <code>await</code> pattern to capture your images. All <code>raspistill</code> arguments (except for those that control user interaction such as <code>-k</code>) are available via the <code>CameraStillSettings</code>. To start, create a new instance of the <code>CameraStillSettings</code> class and pass it on to your choice of the <code>Pi.Camera.CaptureImage*</code> methods. There are shortcut methods available that simply take a JPEG image at the given Width and Height. By default, the shortcut methods set the JPEG quality at 90%.</p>
<p>Example using a shortcut method:</p>
<pre><code class="lang-csharp">static void TestCaptureImage()
{
    var pictureBytes = Pi.Camera.CaptureImageJpeg(640, 480);
    var targetPath = &quot;/home/pi/picture.jpg&quot;;
    if (File.Exists(targetPath))
        File.Delete(targetPath);

    File.WriteAllBytes(targetPath, pictureBytes);
    Console.WriteLine($&quot;Took picture -- Byte count: {pictureBytes.Length}&quot;);
}
</code></pre><p>Example using a CaptureImage method:</p>
<pre><code class="lang-csharp">// TODO: example code here
</code></pre><h3 id="capturing-video">Capturing Video</h3>
<p>Capturing video streams is somewhat different but it is still very easy to do. The concept behind it is to <em>Open</em> a video stream providing your own callback. When opening the stream <code>Raspberry IO</code> will spawn a separte thread and will not block the execution of your code, but it will continually call your callback method containing the bytes that are being read from the camera until the <em>Close</em> method is called or until the timeout is reached.</p>
<p>Example of capturing a stream of H.264 video</p>
<pre><code class="lang-csharp">static void TestCaptureVideo()
{
    // Setup our working variables
    var videoByteCount = 0;
    var videoEventCount = 0;
    var startTime = DateTime.UtcNow;

    // Configure video settings
    var videoSettings = new CameraVideoSettings()
    {
        CaptureTimeoutMilliseconds = 0,
        CaptureDisplayPreview = false,
        ImageFlipVertically = true,
        CaptureExposure = CameraExposureMode.Night,
        CaptureWidth = 1920,
        CaptureHeight = 1080
    };

    try
    {
        // Start the video recording
        Pi.Camera.OpenVideoStream(videoSettings,
            onDataCallback: (data) =&gt; { videoByteCount += data.Length; videoEventCount++; },
            onExitCallback: null);

        // Wait for user interaction
        startTime = DateTime.UtcNow;
        Console.WriteLine(&quot;Press any key to stop reading the video stream . . .&quot;);
        Console.ReadKey(true);
    }
    catch (Exception ex)
    {
        Console.WriteLine($&quot;{ex.GetType()}: {ex.Message}&quot;);
    }
    finally
    {
        // Always close the video stream to ensure raspivid quits
        Pi.Camera.CloseVideoStream();

        // Output the stats
        var megaBytesReceived = (videoByteCount / (1024f * 1024f)).ToString(&quot;0.000&quot;);
        var recordedSeconds = DateTime.UtcNow.Subtract(startTime).TotalSeconds.ToString(&quot;0.000&quot;);
        Console.WriteLine($&quot;Capture Stopped. Received {megaBytesReceived} Mbytes in {videoEventCount} callbacks in {recordedSeconds} seconds&quot;);
    }            
}
</code></pre><h2 id="obtaining-board-and-system-information">Obtaining Board and System Information</h2>
<p><code>RaspberryIO</code> contains useful utilities to obtain information about the board it is running on. You can simply call the <code>Pi.Info.ToString()</code> method to obtain a dump of all system properties as a single <code>string</code>, or you can use the individual properties such as Installed RAM, Processor Count, Raspberry Pi Version, Serial Number, etc. There&#39;s not a lot more to this.
Please note <code>Pi.Info</code> depends on <code>Wiring Pi</code>, and the <code>/proc/cpuinfo</code> and <code>/proc/meminfo</code> files.</p>
<h2 id="using-the-gpio-pins">Using the GPIO Pins</h2>
<p>Pin reference for the B plus (B+) - Header P1</p>
<table>
<thead>
<tr>
<th>BCM</th>
<th>wPi</th>
<th>Name</th>
<th>Mode</th>
<th>V</th>
<th>L</th>
<th>R</th>
<th>V</th>
<th>Mode</th>
<th>Name</th>
<th>wPi</th>
<th>BCM</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>3.3v</td>
<td></td>
<td></td>
<td><strong>01</strong></td>
<td><strong>02</strong></td>
<td></td>
<td></td>
<td>5v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>8</td>
<td>SDA.1</td>
<td>ALT0</td>
<td>1</td>
<td><strong>03</strong></td>
<td><strong>04</strong></td>
<td></td>
<td></td>
<td>5V</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>9</td>
<td>SCL.1</td>
<td>ALT0</td>
<td>1</td>
<td><strong>05</strong></td>
<td><strong>06</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>7</td>
<td>GPIO. 7</td>
<td>IN</td>
<td>1</td>
<td><strong>07</strong></td>
<td><strong>08</strong></td>
<td>1</td>
<td>ALT0</td>
<td>TxD</td>
<td>15</td>
<td>14</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>09</strong></td>
<td><strong>10</strong></td>
<td>1</td>
<td>ALT0</td>
<td>RxD</td>
<td>16</td>
<td>15</td>
</tr>
<tr>
<td>17</td>
<td>0</td>
<td>GPIO. 0</td>
<td>IN</td>
<td>0</td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 1</td>
<td>1</td>
<td>18</td>
</tr>
<tr>
<td>27</td>
<td>2</td>
<td>GPIO. 2</td>
<td>IN</td>
<td>0</td>
<td><strong>13</strong></td>
<td><strong>04</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>3</td>
<td>GPIO. 3</td>
<td>IN</td>
<td>0</td>
<td><strong>15</strong></td>
<td><strong>06</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 4</td>
<td>4</td>
<td>23</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.3v</td>
<td></td>
<td></td>
<td><strong>17</strong></td>
<td><strong>08</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 5</td>
<td>5</td>
<td>24</td>
</tr>
<tr>
<td>10</td>
<td>12</td>
<td>MOSI</td>
<td>IN</td>
<td>0</td>
<td><strong>19</strong></td>
<td><strong>20</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>13</td>
<td>MISO</td>
<td>IN</td>
<td>0</td>
<td><strong>21</strong></td>
<td><strong>22</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO. 6</td>
<td>6</td>
<td>25</td>
</tr>
<tr>
<td>11</td>
<td>14</td>
<td>SCLK</td>
<td>IN</td>
<td>0</td>
<td><strong>23</strong></td>
<td><strong>24</strong></td>
<td>1</td>
<td>IN</td>
<td>CE0</td>
<td>10</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>25</strong></td>
<td><strong>26</strong></td>
<td>1</td>
<td>IN</td>
<td>CE1</td>
<td>11</td>
<td>7</td>
</tr>
<tr>
<td>0</td>
<td>30</td>
<td>SDA.0</td>
<td>IN</td>
<td>1</td>
<td><strong>27</strong></td>
<td><strong>28</strong></td>
<td>1</td>
<td>IN</td>
<td>SCL.0</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>21</td>
<td>GPIO.21</td>
<td>IN</td>
<td>1</td>
<td><strong>29</strong></td>
<td><strong>30</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>22</td>
<td>GPIO.22</td>
<td>IN</td>
<td>1</td>
<td><strong>31</strong></td>
<td><strong>32</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.26</td>
<td>26</td>
<td>12</td>
</tr>
<tr>
<td>13</td>
<td>23</td>
<td>GPIO.23</td>
<td>IN</td>
<td>0</td>
<td><strong>33</strong></td>
<td><strong>34</strong></td>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>24</td>
<td>GPIO.24</td>
<td>IN</td>
<td>0</td>
<td><strong>35</strong></td>
<td><strong>36</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.27</td>
<td>27</td>
<td>16</td>
</tr>
<tr>
<td>26</td>
<td>25</td>
<td>GPIO.25</td>
<td>IN</td>
<td>0</td>
<td><strong>37</strong></td>
<td><strong>38</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.28</td>
<td>28</td>
<td>20</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0v</td>
<td></td>
<td></td>
<td><strong>39</strong></td>
<td><strong>40</strong></td>
<td>0</td>
<td>IN</td>
<td>GPIO.29</td>
<td>29</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>But wait a second, Where are Wiring Pi (wPi) pins 17 through 20? The above diagram shows the pins of GPIO Header P1. There is an additional GPIO header on the Pi called P5. <a href="http://www.raspberrypi-spy.co.uk/2012/09/raspberry-pi-p5-header/">More info available here</a></p>
<p>In order to access the pins, use <code>Pi.Gpio</code>. The pins can have multiple behaviors and fortunately <code>Pi.Gpio</code> can be iterated, addressed by index, addessed by Wiring Pi pin number and provides the pins as publicly accessible properties.</p>
<p>Here is an example of addressing the pins in all the various ways:</p>
<pre><code class="lang-csharp">public static void TestLedBlinking()
{
    // Get a reference to the pin you need to use.
    // All 3 methods below are exactly equivalente
    var blinkingPin = Pi.Gpio[0];
    blinkingPin = Pi.Gpio[WiringPiPin.Pin00];
    blinkingPin = Pi.Gpio.Pin00;

    // Configure the pin as an output
    blinkingPin.PinMode = GpioPinDriveMode.Output;

    // perform writes to the pin by toggling the isOn variable
    var isOn = false;
    for (var i = 0; i &lt; 20; i++)
    {
        isOn = !isOn;
        blinkingPin.Write(isOn);
        System.Threading.Thread.Sleep(500);
    }
}
</code></pre><h3 id="pin-information">Pin Information</h3>
<p>All pins have handy properties and methods that you can use to drive them. For example you can examine the <code>Capabilities</code> property to find out which features are avilable on the pin. You can also use the <code>PinMode</code> property to get or set the operating mode of the pin. Please note that the value of the <code>PinMode</code> property is by default set to <em>Input</em> and it will return the last mode you set the property to.</p>
<h3 id="digital-read-and-write">Digital Read and Write</h3>
<p>It is very easy to read and write values to the pins. In general, it is a 2-step process.</p>
<ul>
<li>Set the pin mode</li>
<li>Read or write the bit value</li>
</ul>
<p>Reading the value of a pin example:</p>
<pre><code class="lang-csharp">Pi.Gpio.Pin02.PinMode = GpioPinDriveMode.Input;
// The below lines are reoughly equivalent
var isOn = Pi.Gpio.Pin02.Read(); // Reads as a boolean
var pinValue = Pi.Gpio.Pin02.ReadValue(); // Reads as a GpioPinValue
</code></pre><p>Writing to a pin example</p>
<pre><code class="lang-csharp">Pi.Gpio.Pin02.PinMode = GpioPinDriveMode.Output;
// The below lines are reoughly equivalent
Pi.Gpio.Pin02.Write(true); // Writes a boolean
Pi.Gpio.Pin02.Write(GpioPinValue.High); // Writes a pin value
</code></pre><h3 id="analog-level-read-and-write">Analog (Level) Read and Write</h3>
<p>TODO</p>
<h3 id="hardware-pwm">Hardware PWM</h3>
<p>TODO</p>
<h3 id="software-pwm">Software PWM</h3>
<p>TODO</p>
<h3 id="tone-generation">Tone Generation</h3>
<p>TODO</p>
<h3 id="interrupts-and-callbacks">Interrupts and Callbacks</h3>
<p>TODO</p>
<h2 id="using-the-spi-bus">Using the SPI Bus</h2>
<p>I really liked the following description from <a href="http://nrqm.ca/nrf24l01/serial-peripheral-interface/">Neil&#39;s Log Book</a>: <em>The SPI (Serial Peripheral Interface) protocol behaves like a ring buffer, so that whenever the master sends a byte to the slave, the slave sends a byte back to the master. The slave can use this behaviour to return a status byte, a response to a previous byte, or null data (the master may choose to read the returned byte, or ignore it). The bus operates on a 4-wire interface.</em></p>
<p><code>RaspberryIO</code> provides easy access to the 2 SPI channels available on the Raspberry. The functionality depends on <code>Wiring Pi</code>&#39;s SPI library. Please note that you may need to issue the command <code>gpio load spi</code> before starting your application (or as a <code>System.Diagnostics.Process</code> when your application starts) if the SPI kernel drivers have not been loaded.</p>
<p>In order to use an SPI channel you <strong>MUST</strong> always set the <code>Channel0Frequency</code> or <code>Channel1Frequency</code> (depending on the channel you want to use) before calling the <code>SendReceive</code> method. If the property is not set beforehand the SPI channel will fail initialization. See an example below: </p>
<p>Example of using the SPI Bus</p>
<pre><code class="lang-csharp">Pi.Spi.Channel0Frequency = SpiChannel.MinFrequency;
var request = System.Text.Encoding.ASCII.GetBytes(&quot;HELLO!&quot;);
var response = Pi.Spi.Channel0.SendReceive(request);
</code></pre><h2 id="i2c-to-connect-ics">I2C to connect ICs</h2>
<p>The Inter IC Bus (I2C) is a cousin of the SPI bus but it is somewhat more complex and it does not work as a ring buffer like the SPI bus. It also connects all of its slave devices in series and depends on 2 lines only. There is a nice tutorial on setting up and using the I2C bus at <a href="http://www.robot-electronics.co.uk/i2c-tutorial">Robot Electronics</a>. From their site: <em>The physical bus is just two wires, called SCL and SDA. SCL is the clock line. It is used to synchronize all data transfers over the I2C bus. SDA is the data line. The SCL &amp; SDA lines are connected to all devices on the I2C bus. There needs to be a third wire which is just the ground or 0 volts. There may also be a 5volt wire is power is being distributed to the devices. Both SCL and SDA lines are &quot;open drain&quot; drivers. What this means is that the chip can drive its output low, but it cannot drive it high. For the line to be able to go high you must provide pull-up resistors to the 5v supply. There should be a resistor from the SCL line to the 5v line and another from the SDA line to the 5v line. You only need one set of pull-up resistors for the whole I2C bus, not for each device.</em></p>
<p><code>RaspberryIO</code> provides easy access to the I2C bus available on the Raspberry. The functionality depends on <code>Wiring Pi</code>&#39;s I2C library. Please note that you may need to issue the command <code>gpio load i2c</code> before starting your application (or as a <code>System.Diagnostics.Process</code> when your application starts) if the I2C kernel drivers have not been loaded. The default baud rate is 100Kbps. If you wish to initialize the bus at a different baud rate you may issue for example, <code>gpio load i2c 200</code>. This will load the bus at 200kbps.</p>
<p>In order to detect I2C devices you could use the <code>i2cdetect</code> system command. Just remember that on a Rev 1 Raspberry Pi it&#39;s device 0, and on a Rev. 2 it&#39;s device 1. e.g.</p>
<pre><code>i2cdetect -y 0 # Rev 1
i2cdetect -y 1 # Rev 2
</code></pre><p>Example of using the I2C Bus</p>
<pre><code class="lang-csharp">// Register a device on the bus
var myDevice = Pi.I2c.AddDevice(0x20);

// Simple Write and Read (there are algo register read and write methods)
myDevice.Write(0x44);
var response = myDevice.Read();

// List registered devices on the I2C Bus
foreach (var device in Pi.I2c.Devices)
{
    Console.WriteLine($&quot;Registered I2C Device: {device.DeviceId}&quot;);
}
</code></pre><h2 id="timing-and-threading">Timing and Threading</h2>
<p>TODO</p>
<h2 id="serial-ports-uart">Serial Ports (UART)</h2>
<p>Where is the serial port API? Well, it is something we will most likely add in the future. For now, you can simply use the built-in <code>SerialPort</code> class the .NET framework provides.</p>
<h2 id="similar-projects">Similar Projects</h2>
<ul>
<li><a href="https://github.com/raspberry-sharp/raspberry-sharp-io">Raspberry# IO</a></li>
<li><a href="https://github.com/danriches/WiringPi.Net">WiringPi.Net</a></li>
<li><a href="https://github.com/andycb/PiSharp">PiSharp</a></li>
</ul>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/unosquare/raspberryio/blob/master/README.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
